---
slug: /fp/1
description: 介绍函数式编程的基本概念
---

### 函数是一等公民

函数在 js 中是一等公民，即函数和所有其他类型一样没有什么不同，可以像对待任何其他数据一样对待函数

```typescript
//不好的写法
httpGet('/post/2', (json, err) => renderPost(json, err))

//好的写法, 及时增加参数也不需要修改
httpGet('/post/2', renderPost)

//不好的写法,丢失了this
fs.readFile('test.txt', Db.save)

//好一点的写法
fs.readFile('test.txt', Db.save.bind(Db))
```

### 纯函数的好处

什么是纯函数？

> 纯函数是这样一种函数，即相同的输入，永远还会得到相同的输出，而且没有任何可观察的副作用

什么是副作用？

> 副作用是在计算过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互

追求纯函数的理由

- **可缓存性(Cacheable)**：由于纯函数的定义，我们可以将计算过的结果进行缓存
- **可移植性(Portable)**：由于其不依赖系统环境，因此移植简单，只要按照定义的方式可以在任何地方运行，我们可以根据函数标签得到更多的信息
- **可测试性(Testable)**：不依赖系统环境，因此测试时只需要对设定输入并对输出进行断言
- **合理性(Reasonable)**：纯函数是引用透明的，一段纯函数可以替换为他执行所得的结果，更方便代码分析

### 不可或缺的 Curry

curry 的概念：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
可以一次性地调用 curry 函数，也可以每次只传一个参数分多次调用。

curry 通过局部调用的方式得到一些“预加载”的函数，减少了样板文件代码

### 组合 Compose

compose 通过将一系列函数组合到一起，让数据能够在该管道中进行流动，它创建了一个从右到左的数据流，这样做的可读性远远高于嵌套一大堆的函数调用，我们可以通过从右到左的方法调用了解数据从输入到输出经过了哪些方法。

**pointfree**

```typescript
// 非 pointfree，因为提到了数据：word
var snakeCase = function (word) {
  return word.toLowerCase().replace(/\s+/gi, '_')
}

// pointfree
var snakeCase = compose(replace(/\s+/gi, '_'), toLowerCase)
```

pointfree 可以减少不必要的命名，在第一个方法中需要 word 参数采用进行后续操作

**debug**

在使用组合函数遇到问题时可以使用 debug 函数追踪代码执行情况

```typescript
var trace = curry(function (tag, x) {
  console.log(tag, x)
  return x
})

var dasherize = compose(
  join('-'),
  // error-next-line
  toLower,
  trace('after split'),
  split(' '),
  replace(/\s{2,}/gi, ' ')
)

dasherize('The world is a vampire')
// after split [ 'The', 'world', 'is', 'a', 'vampire' ]
// TypeError: Cannot read property 'apply' of undefined
```

### 练习

Curry

```typescript
var _ = require('ramda')

// 练习 1
//==============
// 通过局部调用（partial apply）移除所有参数

var words = function (str) {
  return split(' ', str)
}
//highlight-start
//solution
words = split(' ')
//highlight-end
// 练习 1a
//==============
// 使用 `map` 创建一个新的 `words` 函数，使之能够操作字符串数组

var sentences = undefined
//highlight-start
//solution
sentences = map(words)
//highlight-end

// 练习 2
//==============
// 通过局部调用（partial apply）移除所有参数

var filterQs = function (xs) {
  return filter(function (x) {
    return match(/q/i, x)
  }, xs)
}
// highlight-start
//solution
filterQs = filter((x) => match(/q/i, x))
// highlight-end

// 练习 3
//==============
// 使用帮助函数 `_keepHighest` 重构 `max` 使之成为 curry 函数

// 无须改动:
var _keepHighest = function (x, y) {
  return x >= y ? x : y
}

// 重构这段代码:
var max = function (xs) {
  return reduce(
    function (acc, x) {
      return _keepHighest(acc, x)
    },
    -Infinity,
    xs
  )
}
// highlight-start
//solution
max = reduce((acc, x) => _keepHighest(acc, x), 0)
// highlight-end
// 彩蛋 1:
// ============
// 包裹数组的 `slice` 函数使之成为 curry 函数
// //[1,2,3].slice(0, 2)
var slice = undefined
// highlight-start
//solution
slice = curry(function (start, end, arr) {
  return arr.slice(start, end)
})
// highlight-end

// 彩蛋 2:
// ============
// 借助 `slice` 定义一个 `take` curry 函数，该函数调用后可以取出字符串的前 n 个字符。
var take = undefined
// highlight-start
//solution
take = slice(0)
// highlight-end
```

Compose

```typescript
require('../../support')
var _ = require('ramda')
var accounting = require('accounting')

// 示例数据
var CARS = [
  {
    name: 'Ferrari FF',
    horsepower: 660,
    dollar_value: 700000,
    in_stock: true
  },
  {
    name: 'Spyker C12 Zagato',
    horsepower: 650,
    dollar_value: 648000,
    in_stock: false
  },
  {
    name: 'Jaguar XKR-S',
    horsepower: 550,
    dollar_value: 132000,
    in_stock: false
  },
  {
    name: 'Audi R8',
    horsepower: 525,
    dollar_value: 114200,
    in_stock: false
  },
  {
    name: 'Aston Martin One-77',
    horsepower: 750,
    dollar_value: 1850000,
    in_stock: true
  },
  {
    name: 'Pagani Huayra',
    horsepower: 700,
    dollar_value: 1300000,
    in_stock: false
  }
]

// 练习 1:
// ============
// 使用 _.compose() 重写下面这个函数。提示：_.prop() 是 curry 函数
var isLastInStock = function (cars) {
  var last_car = _.last(cars)
  return _.prop('in_stock', last_car)
}
// highlight-start
//solution
isLastInStock = compose(prop('in_stock'), last)
// highlight-end

// 练习 2:
// ============
// 使用 _.compose()、_.prop() 和 _.head() 获取第一个 car 的 name
var nameOfFirstCar = undefined
// highlight-start
//solution
nameOfFirstCar = compose(prop('name'), head)
//highlight-end

// 练习 3:
// ============
// 使用帮助函数 _average 重构 averageDollarValue 使之成为一个组合
var _average = function (xs) {
  return reduce(add, 0, xs) / xs.length
} // <- 无须改动

var averageDollarValue = function (cars) {
  var dollar_values = map(function (c) {
    return c.dollar_value
  }, cars)
  return _average(dollar_values)
}
// highlight-start
//solution
averageDollarValue = compose(_average, prop('dollar_value'))
// highlight-end

// 练习 4:
// ============
// 使用 compose 写一个 sanitizeNames() 函数，返回一个下划线连接的小写字符串：例如：sanitizeNames(["Hello World"]) //=> ["hello_world"]。

var _underscore = replace(/\W+/g, '_') //<-- 无须改动，并在 sanitizeNames 中使用它

var sanitizeNames = undefined
// highlight-start
//solution
sanitizeNames = map(compose(toLower, _underscore, prop('name')))
// highlight-end

// 彩蛋 1:
// ============
// 使用 compose 重构 availablePrices

var availablePrices = function (cars) {
  var available_cars = _.filter(_.prop('in_stock'), cars)
  return available_cars
    .map(function (x) {
      return accounting.formatMoney(x.dollar_value)
    })
    .join(', ')
}
// highlight-start
//solution
availablePrices = compose(
  join(', '),
  map(compose(accounting.formatMoney, prop('dollar_value'))),
  filter(prop('in_stock'))
)
// highlight-end

// 彩蛋 2:
// ============
// 重构使之成为 pointfree 函数。提示：可以使用 _.flip()

var fastestCar = function (cars) {
  var sorted = _.sortBy(function (car) {
    return car.horsepower
  }, cars)
  var fastest = _.last(sorted)
  return fastest.name + ' is the fastest'
}
// highlight-start
//solution
fastestCar = compose(
  (name) => name + ' is the fastest',
  prop('name'),
  last,
  sortBy((car) => car.horsepower)
)
// highlight-end
```
