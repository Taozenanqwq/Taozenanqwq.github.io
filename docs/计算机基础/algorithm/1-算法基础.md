---
slug: /alg/foundation
---

### 枚举

主要思想：从可能集合中通过尝试得到最终答案

步骤：

- 给出所有解空间
- 缩小解空间
- 确定枚举顺序

**例题**

```typescript
// highlight-next-line
//题1：一个数组中的数互不相同，求其中何为 0 的数对个数
function getZeroPair(arr: number[]): number {
  const map = new Map()
  for (let num of arr) {
    map.set(num, 1)
  }
  let res = 0
  for (let num of Object.keys(map)) {
    if (map.has(0 - num)) res++
  }
  return res * 2
}

// highlight-next-line
//题2：熄灯问题：
// 解法：根据提示可知只有第一行是不确定的，因此使用枚举第一行的不同可能判断是否最后能关闭所有灯
function lightDown(mat) {
  let flag = false
  let res = false
  const len = mat.length
  const record = new Array(mat[0].length).fill(0)
  function triggerLight(mat, i, j) {
    mat[i][j] = 1 - mat[i][j]
    if (j + 1 < mat[0].length) mat[i][j + 1] = 1 - mat[i][j + 1]
    if (j - 1 >= 0) mat[i][j - 1] = 1 - mat[i][j - 1]
    if (i + 1 < mat.length) mat[i + 1][j] = 1 - mat[i + 1][j]
    if (i - 1 >= 0) mat[i - 1][j] = 1 - mat[i - 1][j]
  }
  function processRestLines(mat) {
    mat = mat.map((v) => Array.from(v))
    const temp = [record.slice()]
    for (let i = 1; i < len; i++) {
      const target = mat[i - 1]
      temp.push(target.slice())
      target.forEach((v, j) => {
        if (v == 1) triggerLight(mat, i, j)
      })
    }
    if (mat[len - 1].every((v) => v === 0)) return temp
    return false
  }
  function processOneLight(mat, i, n) {
    if (flag) return
    if (i == n) {
      if ((res = processRestLines(mat))) {
        flag = true
      }
      return
    }
    record[i] = 0
    processOneLight(mat, i + 1, n)
    triggerLight(mat, 0, i)
    record[i] = 1
    processOneLight(mat, i + 1, n)
    triggerLight(mat, 0, i)
  }
  processOneLight(mat, 0, mat[0].length)
  return res
}
```
