---
slug: /create-pattern/builder
description: 生成器模式能够分步骤创建复杂对象，该模式允许使用相同的创建代码生成不同类型和形式的对象。
---

### 概念

抽象工厂模式在面对可以抽象为几类的简单创建过程能够发挥作用，但在面对更加定制化的、更复杂的且难以分层的创建过程则无法发挥作用，而生成器模式则能够很好地处理这种情况，通过分步骤的创建方式能够能好地面对这种难以抽象为不同类型的情况，生成器模式解决了在这种情况下使用参数进行创建则会面临每次创建都需要传递大量参数（即使有些参数是不需要的）或需要多个重载函数的问题。

除了在创建复杂对象时存在的优势外，生成器还能够实现对相同创建过程、不同实现细节的对象进行创建，这些对象可以不实现相同的接口，假如我们想要生产一个车类对象同时生产与其相关的使用手册，如果使用抽象工厂模式我们是很难做到的，因为抽象工厂模式更加注重的是不同系列产品的抽象，而对于每个产品具体的生产过程并没有进一步抽象，因此即使两类生产过程完全相同的产品也无法复用原有的生产过程；而生成器模式不同，由于其对生产过程的抽象，我们可以复用生产过程这一基类，因为两者在功能上是相对应的，车的每一部分生产过程都会涉及到对应的使用手册撰写过程，因此我们可以基于同一抽象的生产过程，通过不同的实现方式生产完全不同的产品

在使用生成器时，客户端有两种调用方法：

- 根据需要的创建步骤有选择地执行不同模块的创建方法，完成对象的创建
- 利用桥接模式，创建主管类进行对象的创建，主管类通过定义好创建步骤并利用具体的生成器完成对象创建，在我们需要一些预设好的创建方式提供给客户端时这是一种很好的方式

### 代码

假设我们希望创建一个房屋，和对应的房屋结构说明书

```typescript
class House {
  constructor() {}
}
class Instruction {
  constructor() {}
}
abstract class Builder {
  constructor() {}
  buildRoom() {}
  buildPool() {}
  buildBackYard() {}
  getProduct() {}
}
//房屋创建builder
class HouseBuilder extends Builder {
  constructor() {
    this.house = new House()
  }
  reset() {
    this.house.reset()
  }
  buildRoom() {}
  buildPool() {}
  buildBackYard() {}
  getProduct() {
    return this.house
  }
}
//房屋结构说明书创建Builder，创建过程一样因此使用同一基类
class HouseInstrution extends Builder {
  constructor() {
    this.instruction = new Instruction()
  }
  reset() {
    this.instruction.reset()
  }
  buildRoom() {}
  buildPool() {}
  buildBackYard() {}
  getProduct() {
    return this.instruction
  }
}
//管家类，预设好户型1和户型2，客户端可以直接调用
class Director {
  constructor() {}
  buildHouse1(builder: Builder) {
    builder.buildRoom(2)
    builder.buildPool()
    builder.buildBackYard()
  }
  buildHouse2(builder: Builder) {
    //房型2创建过程
    //...
  }
}

class Application {
  constructor() {}
  buildHouse() {
    //使用管家类分别创建户型1和对应的说明书
    director = new Director()
    houseBuilder = new HouseBuilder()
    instructionBuilder = new instructionBuilder()
    director.buildHouse1(houseBuilder)
    director.buildHouse2(instructionBuilder)
    house = houseBuilder.getProduct()
    instruction = instructionBuilder.getProduct()
  }
}
```
