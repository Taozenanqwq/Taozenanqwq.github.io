---
slug: /create-pattern/abstract-factory
description: 抽象工厂能创建一系列相关的对象， 而无需指定其具体类
---

### 概念

工厂模式主要针对单一对象的创建进行处理，解耦其创建过程与客户端的使用过程，而在实际的场景中遇到的情况会更复杂，可能会同时生产一批同系列的产品，这种情况下可以通过抽象出产品的系列，每个系列的产品使用同一个工厂进行生产（**抽象工厂是一系列工厂方法的集合**），在父级抽象类中定义好这些不同系列工厂生产不同产品的接口、创建方法返回的产品的接口，从而将产品的创建与具体的产品系列解耦，客户端使用时根据自身情况选择一个想要使用的系列后，通过对应的工厂方法创建所需使用的产品后使用定义后的接口进行应用，其中涉及到的**创建产品和应用产品的接口已经提前定义好**因此与创建过程完全解耦。

[更多细节](https://refactoringguru.cn/design-patterns/abstract-factory)

### 代码

假设当前我们在设计一个游戏，根据用户选择不同在一开始会获得一个英雄和对应的宠物，每个英雄都会攻击和释放技能，每个宠物都会守护

```typescript
//hero和pet在此处作为产品，定义产品接口，此处包含两个产品Pet和Hero
abstract class Hero {
  constructor() {}
  attack() {}
  relaseSkill() {}
}
abstract class Pet {
  constructor() {}
  defend() {}
}
//产品共两个系列，分别为系列1、系列2
class Hero1 extends Hero {
  constructor() {}
  attack() {}
  relaseSkill() {}
}
class Hero2 extends Hero {
  constructor() {}
  attack() {}
  relaseSkill() {}
}

class Pet1 extends Pet {
  constructor() {}
  defend() {}
}

class Pet2 extends Pet {
  constructor() {}
  defend() {}
}

//抽象工厂Creator定义创建产品接口
abstract class Creator {
  constructor() {}
  createHero() {}
  createPet() {}
}

class Series1Creator {
  constructor() {}
  createHero() {
    return new Hero1()
  }
  createPet() {
    return new Pet2()
  }
}
class Series2Creator {
  constructor() {}
  createHero() {
    return new Hero2()
  }
  createPet() {
    return new Pet2()
  }
}

//主应用
class Game {
  constructor(heroName) {
    //可以进一步通过配置的模式解耦这部分代码
    this.creator =
      heroName == 'hero1'
        ? new Series1Creator()
        : new Series2Creator()
  }
  createHero() {
    this.hero = this.creator.createHero()
  }
  createPet() {
    this.pet = this.pet.createPet()
  }
}
```

优点：

- 同一工厂生产的产品相互匹配
- 避免客户端和具体产品代码耦合
- 单一职责原则。工厂负责产品生产逻辑，代码易于维护
- 开闭原则。引入新的系列时无需修改客户端代码

缺点：

- 引入众多类和接口，提升代码复杂度
